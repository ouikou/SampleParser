/*	Grammar file*//*	JavaCC default options, if you change these add a comment why*/options{  MULTI = true;  STATIC = false;  VISITOR = true;  NODE_FACTORY = true;  DEBUG_PARSER = false;  NODE_USES_PARSER = true;  JAVA_UNICODE_ESCAPE = true;  OUTPUT_DIRECTORY = "../ast";}PARSER_BEGIN(TMParser)package parser.textmodel.ast;import java.util.*;public class TMParser{  // Hastable for storing typedef types  private static Set types = new HashSet();  {    // Hack to include type "special types"    types.add("__signed__");    types.add("__const");    types.add("__inline__");    types.add("__signed");  }  // Stack for determining when the parser  // is parsing a typdef definition.  private static Stack typedefParsingStack = new Stack();  // Returns true if the given string is  // a typedef type.  private static boolean isType(String type)  {    return types.contains(type);  }  // Add a typedef type to those already defined  private static void addType(String type)  {    types.add(type);  }  // Prints out all the types used in parsing the c source  private static void printTypes()  {    for (Iterator i = types.iterator(); i.hasNext();)    {      System.out.println(i.next());    }  }  // Run the parser  public static void main(String args [])  {    TMParser parser;    if (args.length == 0)    {      System.out.println("C Parser:  Reading from standard input . . .");      parser = new TMParser(System.in);    }    else if (args.length == 1)    {      System.out.println("C Parser:  Reading from file " + args [0] + " . . .");      try      {        parser = new TMParser(new java.io.FileInputStream(args [0]));      }      catch (java.io.FileNotFoundException e)      {        System.out.println("C Parser:  File " + args [0] + " not found.");        return;      }    }    else    {      System.out.println("C Parser:  Usage is one of:");      System.out.println("        TMParser < inputfile");      System.out.println("OR");      System.out.println("        TMParser inputfile");      return;    }    try    {      ASTTranslationUnit unit = parser.TranslationUnit();      System.out.println("C Parser:  Parsed successfully.");    }    catch (ParseException e)    {      System.out.println("C Parser:  Encountered errors during parse.");      e.printStackTrace();    }  }}PARSER_END(TMParser)SKIP :{  " "| "\t"| "\n"| "\r"| < "//" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    ) >| < "/*" (~[ "*" ])+ "*"    (      "*"    | ~[ "*", "/" ] (~[ "*" ])* "*"    )*    "/" >| < "/***" (~[ "*" ])* "*"    (      "*"    | ~[ "*", "/" ] (~[ "*" ])* "*"    )*    "/" >| "#" : PREPROCESSOR_OUTPUT}< PREPROCESSOR_OUTPUT >SKIP :{  "\n" : DEFAULT}< PREPROCESSOR_OUTPUT >MORE :{  "\\\n"| "\\\r\n"| < ~[ ] >}TOKEN :{  < INTEGER_LITERAL :    < DECIMAL_LITERAL > ([ "l", "L" ])?  | < HEX_LITERAL > ([ "l", "L" ])?  | < OCTAL_LITERAL > ([ "l", "L" ])? >| < #DECIMAL_LITERAL : [ "1"-"9" ] ([ "0"-"9" ])* >| < #HEX_LITERAL : "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])+ >| < #OCTAL_LITERAL : "0" ([ "0"-"7" ])* >| < FLOATING_POINT_LITERAL :    ([ "0"-"9" ])+ "." ([ "0"-"9" ])* (< EXPONENT >)? ([ "f", "F", "d", "D" ])?  | "." ([ "0"-"9" ])+ (< EXPONENT >)? ([ "f", "F", "d", "D" ])?  | ([ "0"-"9" ])+ < EXPONENT > ([ "f", "F", "d", "D" ])?  | ([ "0"-"9" ])+ (< EXPONENT >)? [ "f", "F", "d", "D" ] >| < #EXPONENT : [ "e", "E" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >| < CHARACTER_LITERAL :    "\'"    (      ~[ "\'", "\\", "\n", "\r" ]    | "\\"      (        [ "n", "t", "b", "r", "f", "\\", "\'", "\"" ]      | [ "0"-"7" ] ([ "0"-"7" ])?      | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]      )    )    "\'" >| < STRING_LITERAL :    "\""    (      ~[ "\"", "\\", "\n", "\r" ]    | "\\"      (        [ "n", "t", "b", "r", "f", "\\", "\'", "\"" ]      | [ "0"-"7" ] ([ "0"-"7" ])?      | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]      |        (          [ "\n", "\r" ]        | "\r\n"        )      )    )*    "\"" >}TOKEN :{  < CONTINUE : "continue" >| < VOLATILE : "volatile" >| < REGISTER : "register" >| < UNSIGNED : "unsigned" >| < TYPEDEF : "typedef" >| < DFLT : "default" >| < DOUBLE : "double" >| < SIZEOF : "sizeof" >| < SWITCH : "switch" >| < RETURN : "return" >| < EXTERN : "extern" >| < STRUCT : "struct" >| < STATIC : "static" >| < SIGNED : "signed" >| < WHILE : "while" >| < BREAK : "break" >| < UNION : "union" >| < CONST : "const" >| < FLOAT : "float" >| < SHORT : "short" >| < ELSE : "else" >| < CASE : "case" >| < LONG : "long" >| < ENUM : "enum" >| < AUTO : "auto" >| < VOID : "void" >| < CHAR : "char" >| < GOTO : "goto" >| < FOR : "for" >| < INT : "int" >| < IF : "if" >| < DO : "do" >}TOKEN : /* SEPARATORS */{  < LPAREN: "(" >| < RPAREN: ")" >| < LBRACE: "{" >| < RBRACE: "}" >| < LBRACKET: "[" >| < RBRACKET: "]" >| < SEMICOLON: ";" >| < COMMA: "," >}TOKEN :{  < IDENTIFIER :    < LETTER >    (      < LETTER >    | < DIGIT >    )* >| < #LETTER : [ "\u0024", "\u0041"-"\u005a", "\u005f", "\u0061"-"\u007a", "\u00c0"-"\u00d6", "\u00d8"-"\u00f6", "\u00f8"-"\u00ff", "\u0100"-"\u1fff", "\u3040"-"\u318f", "\u3300"-"\u337f", "\u3400"-"\u3d2d", "\u4e00"-"\u9fff", "\uf900"-"\ufaff", "\uff21"-"\uff3a", "\uff41"-"\uff5a" ] >| < #DIGIT : [ "\u0030"-"\u0039", "\u0660"-"\u0669", "\u06f0"-"\u06f9", "\u0966"-"\u096f", "\u09e6"-"\u09ef", "\u0a66"-"\u0a6f", "\u0ae6"-"\u0aef", "\u0b66"-"\u0b6f", "\u0be7"-"\u0bef", "\u0c66"-"\u0c6f", "\u0ce6"-"\u0cef", "\u0d66"-"\u0d6f", "\u0e50"-"\u0e59", "\u0ed0"-"\u0ed9", "\u1040"-"\u1049", "\uff10"-"\uff19" ] >}/* * テキストモデルコメント Parser 処理開始 */TOKEN : /* FORMAL_COMMENT */{  < FORMAL_COMMENT_START : "/**" >| < FORMAL_COMMENT_END : "*/" >| < FORMAL_COMMENT_ANNOTATION_KEY_NAME :    ("*")*    (      " "    | "\t"    )*    "@name"    (      " "    | "\t"    )* >| < FORMAL_COMMENT_ANNOTATION_KEY_PARAM :    ("*")*    (      " "    | "\t"    )*    "@param"    (      " "    | "\t"    )* >}void VariableModelComment() :{}{  < FORMAL_COMMENT_START > commentAnnoName() < FORMAL_COMMENT_END >}void FunctionModelComment() :{}{  < FORMAL_COMMENT_START >  (    commentAnnoName()    (      commentAnnoParam()    )*  )  < FORMAL_COMMENT_END >}void FlowModelComment() :{}{  < FORMAL_COMMENT_START > commentAnnoName() < FORMAL_COMMENT_END >}void commentAnnoName() :{}{  < FORMAL_COMMENT_ANNOTATION_KEY_NAME > < IDENTIFIER >}void commentAnnoParam() :{}{  < FORMAL_COMMENT_ANNOTATION_KEY_PARAM > < IDENTIFIER >}/* テキストモデルコメント Parser 処理完了 *//* * テキストモデル Parser 処理開始 */void TextModelDeclaration() :{}{  (    LOOKAHEAD(FlowModelDefinition())    FlowModelDefinition()  | LOOKAHEAD(VariableModelDeclaration())    VariableModelDeclaration()  | LOOKAHEAD(FunctionModelDeclaration())    FunctionModelDeclaration()  | LOOKAHEAD(FunctionModelDefinition())    FunctionModelDefinition()  )}void VariableModelDeclaration() :{}{  VariableModelComment() DeclarationSpecifiers() [ VariableInitDeclaratorList() ] < SEMICOLON >}void FunctionModelDeclaration() :{}{  FunctionModelComment()  [    LOOKAHEAD(DeclarationSpecifiers())    DeclarationSpecifiers()  ]  FunctionDeclarator() [ FunctionDeclarationList() ] < SEMICOLON >}void FunctionModelDefinition() :{}{  FunctionModelComment()  [    LOOKAHEAD(DeclarationSpecifiers())    DeclarationSpecifiers()  ]  Declarator() [ DeclarationList() ] CompoundStatement()}void FlowModelDefinition() :{}{  FlowModelComment() CompoundStatement()}/* テキストモデル Parser 処理完了 */ASTTranslationUnit TranslationUnit() :{}{  (    LOOKAHEAD(ExternalDeclaration())    ExternalDeclaration()  | TextModelDeclaration() // テキストモデルの解析処理を追加する。  )*  {    return jjtThis;  }}void ExternalDeclaration() :{}{  (    LOOKAHEAD(FunctionDefinition())    FunctionDefinition()  | Declaration()  )}void FunctionDefinition() :{}{  [    LOOKAHEAD(DeclarationSpecifiers())    DeclarationSpecifiers()  ]  Declarator() [ DeclarationList() ] CompoundStatement()}void Declaration() :{}{  DeclarationSpecifiers() [ InitDeclaratorList() ] < SEMICOLON >}void FunctionDeclaration() :{}{  DeclarationSpecifiers() [ FunctionInitDeclaratorList() ] < SEMICOLON >}void VariableDeclaration() :{}{  DeclarationSpecifiers() [ VariableInitDeclaratorList() ] < SEMICOLON >}void DeclarationList() :{}{  (    LOOKAHEAD(Declaration())    Declaration()  )+}void FunctionDeclarationList() :{}{  (    LOOKAHEAD(FunctionDeclaration())    FunctionDeclaration()  )+}void VariableDeclarationList() :{}{  (    LOOKAHEAD(VariableDeclaration())    VariableDeclaration()  )+}void DeclarationSpecifiers() :{}{  StorageClassSpecifier()  [    LOOKAHEAD(DeclarationSpecifiers())    DeclarationSpecifiers()  ]| TypeSpecifier()  [    LOOKAHEAD(MultiDeclarationSpecifiers())    MultiDeclarationSpecifiers()  ]| TypeQualifier()  [    LOOKAHEAD(DeclarationSpecifiers())    DeclarationSpecifiers()  ]}void MultiDeclarationSpecifiers() :{}{  StorageClassSpecifier()  [    LOOKAHEAD(MultiDeclarationSpecifiers())    MultiDeclarationSpecifiers()  ]| MultiTypeSpecifier()  [    LOOKAHEAD(MultiDeclarationSpecifiers())    MultiDeclarationSpecifiers()  ]| TypeQualifier()  [    LOOKAHEAD(MultiDeclarationSpecifiers())    MultiDeclarationSpecifiers()  ]}void StorageClassSpecifier() :{}{  (    < AUTO >  | < REGISTER >  | < STATIC >  | < EXTERN >  | < TYPEDEF >    {      typedefParsingStack.push(Boolean.TRUE);    }  )}void TypeSpecifier() :{}{  (    < VOID >  | < CHAR >  | < SHORT >  | < INT >  | < LONG >  | < FLOAT >  | < DOUBLE >  | < SIGNED >  | < UNSIGNED >  | StructOrUnionSpecifier()  | EnumSpecifier()  | < IDENTIFIER >  )}void MultiTypeSpecifier() :{}{  (    < VOID >  | < CHAR >  | < SHORT >  | < INT >  | < LONG >  | < FLOAT >  | < DOUBLE >  | < SIGNED >  | < UNSIGNED >  | StructOrUnionSpecifier()  | EnumSpecifier()  | LOOKAHEAD({ isType(getToken(1).image) })    TypedefName()  )}void TypeQualifier() :{}{  (    < CONST >  | < VOLATILE >  )}void StructOrUnionSpecifier() :{}{  {    typedefParsingStack.push(Boolean.FALSE);  }  StructOrUnion()  (    LOOKAHEAD(3)    [ < IDENTIFIER > ] < LBRACE > StructDeclarationList() < RBRACE >  | < IDENTIFIER >  )  {    typedefParsingStack.pop();  }}void StructOrUnion() :{}{  (    < STRUCT >  | < UNION >  )}void StructDeclarationList() :{}{  (    StructDeclaration()  )+}void InitDeclaratorList() :{}{  InitDeclarator()  (    < COMMA > InitDeclarator()  )*  {    // Finished with a typedefDeclaration??    if (!(typedefParsingStack.empty()) && ((Boolean) typedefParsingStack.peek()).booleanValue())    {      typedefParsingStack.pop();    }  }}void FunctionInitDeclaratorList() :{}{  FunctionInitDeclarator()  (    < COMMA > FunctionInitDeclarator()  )*  {    // Finished with a typedefDeclaration??    if (!(typedefParsingStack.empty()) && ((Boolean) typedefParsingStack.peek()).booleanValue())    {      typedefParsingStack.pop();    }  }}void VariableInitDeclaratorList() :{}{  VariableInitDeclarator()  (    < COMMA > VariableInitDeclarator()  )*  {    // Finished with a typedefDeclaration??    if (!(typedefParsingStack.empty()) && ((Boolean) typedefParsingStack.peek()).booleanValue())    {      typedefParsingStack.pop();    }  }}void InitDeclarator() :{}{  Declarator() [ "=" Initializer() ]}void FunctionInitDeclarator() :{}{  FunctionDeclarator() [ "=" Initializer() ]}void VariableInitDeclarator() :{}{  VariableDeclarator() [ "=" Initializer() ]}void StructDeclaration() :{}{  SpecifierQualifierList() StructDeclaratorList() < SEMICOLON >}void SpecifierQualifierList() :{}{  TypeSpecifier()  [    LOOKAHEAD(MultiSpecifierQualifierList())    MultiSpecifierQualifierList()  ]| TypeQualifier()  [    LOOKAHEAD(SpecifierQualifierList())    SpecifierQualifierList()  ]}void MultiSpecifierQualifierList() :{}{  MultiTypeSpecifier()  [    LOOKAHEAD(MultiSpecifierQualifierList())    MultiSpecifierQualifierList()  ]| TypeQualifier()  [    LOOKAHEAD(MultiSpecifierQualifierList())    MultiSpecifierQualifierList()  ]}void StructDeclaratorList() :{}{  StructDeclarator()  (    < COMMA > StructDeclarator()  )*}void StructDeclarator() :{}{  (    LOOKAHEAD(3)    Declarator()  | [ Declarator() ] ":" ConstantExpression()  )}void EnumSpecifier() :{}{  < ENUM >  (    LOOKAHEAD(3)    [ < IDENTIFIER > ] < LBRACE > EnumeratorList() < RBRACE >  | < IDENTIFIER >  )}void EnumeratorList() :{}{  Enumerator()  (    < COMMA > Enumerator()  )*}void Enumerator() :{}{  < IDENTIFIER > [ "=" ConstantExpression() ]}void Declarator() :{}{  [ Pointer() ] DirectDeclarator()}void ParameterDeclarator() :{}{  (    [ Pointer() ]    (      VariableDirectDeclarator()    | FunctionPointerDirectDeclarator()    )  )}void FunctionDeclarator() :{}{  (    [ Pointer() ] FunctionDirectDeclarator()  )}void VariableDeclarator() :{}{  (    [ Pointer() ]    (      VariableDirectDeclarator()    | FunctionPointerDirectDeclarator()    )  )}void DirectDeclarator() :{  Token t;}{  (    t = < IDENTIFIER >    {      if (!(typedefParsingStack.empty()) && ((Boolean) typedefParsingStack.peek()).booleanValue())      {        addType(t.image);      }    }  | < LPAREN > Declarator() < RPAREN >  )  {    typedefParsingStack.push(Boolean.FALSE);  }  (    < LBRACKET > [ ConstantExpression() ] < RBRACKET >  | LOOKAHEAD(3)    < LPAREN > ParameterTypeList() < RPAREN >  | < LPAREN > [ IdentifierList() ] < RPAREN >  )*  {    typedefParsingStack.pop();  }}void FunctionDirectDeclarator() :{  Token t;}{  (    t = < IDENTIFIER >    {      if (!(typedefParsingStack.empty()) && ((Boolean) typedefParsingStack.peek()).booleanValue())      {        addType(t.image);      }    }  )  {    typedefParsingStack.push(Boolean.FALSE);  }  (    < LBRACKET > [ ConstantExpression() ] < RBRACKET >  | LOOKAHEAD(3)    < LPAREN > ParameterTypeList() < RPAREN >  | < LPAREN > [ IdentifierList() ] < RPAREN >  )*  {    typedefParsingStack.pop();  }}void FunctionPointerDirectDeclarator() :{  Token t;}{  (    < LPAREN > Declarator() < RPAREN >  )  {    typedefParsingStack.push(Boolean.FALSE);  }  (    < LBRACKET > [ ConstantExpression() ] < RBRACKET >  | LOOKAHEAD(3)    < LPAREN > ParameterTypeList() < RPAREN >  | < LPAREN > [ IdentifierList() ] < RPAREN >  )*  {    typedefParsingStack.pop();  }}void VariableDirectDeclarator() :{  Token t;}{  (    t = < IDENTIFIER >    {      if (!(typedefParsingStack.empty()) && ((Boolean) typedefParsingStack.peek()).booleanValue())      {        addType(t.image);      }    }  )  {    typedefParsingStack.push(Boolean.FALSE);  }  (    < LBRACKET > [ ConstantExpression() ] < RBRACKET >  )*  {    typedefParsingStack.pop();  }}void Pointer() :{}{  "*" [ TypeQualifierList() ] [ Pointer() ]}void TypeQualifierList() :{}{  (    TypeQualifier()  )+}void ParameterTypeList() :{}{  ParameterList() [ < COMMA > "..." ]}void ParameterList() :{}{  ParameterDeclaration()  (    LOOKAHEAD(2)    < COMMA > ParameterDeclaration()  )*}void ParameterDeclaration() :{}{  DeclarationSpecifiers()  (    LOOKAHEAD(ParameterDeclarator())    ParameterDeclarator()  | [ AbstractDeclarator() ]  )}void IdentifierList() :{}{  < IDENTIFIER > (< COMMA > < IDENTIFIER >)*}void Initializer() :{}{  (    AssignmentExpression()  | < LBRACE > InitializerList() [ < COMMA > ] < RBRACE >  )}void InitializerList() :{}{  Initializer()  (    LOOKAHEAD(2)    < COMMA > Initializer()  )*}void TypeName() :{}{  SpecifierQualifierList() [ AbstractDeclarator() ]}void AbstractDeclarator() :{}{  (    LOOKAHEAD(3)    Pointer()  | [ Pointer() ] DirectAbstractDeclarator()  )}void DirectAbstractDeclarator() :{}{  (    LOOKAHEAD(2)    < LPAREN > AbstractDeclarator() < RPAREN >  | < LBRACKET > [ ConstantExpression() ] < RBRACKET >  | < LPAREN > [ ParameterTypeList() ] < RPAREN >  )  (    < LBRACKET > [ ConstantExpression() ] < RBRACKET >  | < LPAREN > [ ParameterTypeList() ] < RPAREN >  )*}void TypedefName() :{}{  < IDENTIFIER >}void Statement() :{}{  (    LOOKAHEAD(2)    LabeledStatement()  | ExpressionStatement()  | CompoundStatement()  | SelectionStatement()  | IterationStatement()  | JumpStatement()  )}void LabeledStatement() :{}{  (    < IDENTIFIER > ":" Statement()  | < CASE > ConstantExpression() ":" Statement()  | < DFLT > ":" Statement()  )}void ExpressionStatement() :{}{  [ Expression() ] < SEMICOLON >}void CompoundStatement() :{}{  < LBRACE >  [    LOOKAHEAD(DeclarationList())    DeclarationList()  ]  [ StatementList() ] < RBRACE >}void StatementList() :{}{  (    Statement()  )+}void SelectionStatement() :{}{  (    < IF > < LPAREN > Expression() < RPAREN > Statement()    [      LOOKAHEAD(2)      < ELSE > Statement()    ]  | < SWITCH > < LPAREN > Expression() < RPAREN > Statement()  )}void IterationStatement() :{}{  (    < WHILE > < LPAREN > Expression() < RPAREN > Statement()  | < DO > Statement() < WHILE > < LPAREN > Expression() < RPAREN > < SEMICOLON >  | < FOR > < LPAREN > [ Expression() ] < SEMICOLON > [ Expression() ] < SEMICOLON > [ Expression() ] < RPAREN > Statement()  )}void JumpStatement() :{}{  (    < GOTO > < IDENTIFIER > < SEMICOLON >  | < CONTINUE > < SEMICOLON >  | < BREAK > < SEMICOLON >  | < RETURN > [ Expression() ] < SEMICOLON >  )}void Expression() :{}{  AssignmentExpression()  (    < COMMA > AssignmentExpression()  )*}void AssignmentExpression() :{}{  LOOKAHEAD(UnaryExpression() AssignmentOperator())  UnaryExpression() AssignmentOperator() AssignmentExpression()| LOOKAHEAD(3)  ConditionalExpression()}void AssignmentOperator() :{}{  (    "="  | "*="  | "/="  | "%="  | "+="  | "-="  | "<<="  | ">>="  | "&="  | "^="  | "|="  )}void ConditionalExpression() :{}{  LogicalORExpression() [ "?" Expression() ":" ConditionalExpression() ]}void ConstantExpression() :{}{  ConditionalExpression()}void LogicalORExpression() :{}{  LogicalANDExpression() [ "||" LogicalORExpression() ]}void LogicalANDExpression() :{}{  InclusiveORExpression() [ "&&" LogicalANDExpression() ]}void InclusiveORExpression() :{}{  ExclusiveORExpression() [ "|" InclusiveORExpression() ]}void ExclusiveORExpression() :{}{  ANDExpression() [ "^" ExclusiveORExpression() ]}void ANDExpression() :{}{  EqualityExpression() [ "&" ANDExpression() ]}void EqualityExpression() :{}{  RelationalExpression()  [    (      "=="    | "!="    )    EqualityExpression()  ]}void RelationalExpression() :{}{  ShiftExpression()  [    (      "<"    | ">"    | "<="    | ">="    )    RelationalExpression()  ]}void ShiftExpression() :{}{  AdditiveExpression()  [    (      "<<"    | ">>"    )    ShiftExpression()  ]}void AdditiveExpression() :{}{  MultiplicativeExpression()  [    (      "+"    | "-"    )    AdditiveExpression()  ]}void MultiplicativeExpression() :{}{  CastExpression()  [    (      "*"    | "/"    | "%"    )    MultiplicativeExpression()  ]}void CastExpression() :{}{  (    LOOKAHEAD(< LPAREN > TypeName() < RPAREN > CastExpression())    < LPAREN > TypeName() < RPAREN > CastExpression()  | UnaryExpression()  )}void UnaryExpression() :{}{  (    LOOKAHEAD(3)    PostfixExpression()  | "++" UnaryExpression()  | "--" UnaryExpression()  | UnaryOperator() CastExpression()  | < SIZEOF >    (      LOOKAHEAD(UnaryExpression())      UnaryExpression()    | < LPAREN > TypeName() < RPAREN >    )  )}void UnaryOperator() :{}{  (    "&"  | "*"  | "+"  | "-"  | "~"  | "!"  )}void PostfixExpression() :{}{  PrimaryExpression()  (    < LBRACKET > Expression() < RBRACKET >  | < LPAREN >    [      LOOKAHEAD(ArgumentExpressionList())      ArgumentExpressionList()    ]    < RPAREN >  | "." < IDENTIFIER >  | "->" < IDENTIFIER >  | "++"  | "--"  )*}void PrimaryExpression() :{}{  (    < IDENTIFIER >  | Constant()  | < LPAREN > Expression() < RPAREN >  )}void ArgumentExpressionList() :{}{  AssignmentExpression()  (    < COMMA > AssignmentExpression()  )*}void Constant() :{}{  < INTEGER_LITERAL >| < FLOATING_POINT_LITERAL >| < CHARACTER_LITERAL >| < STRING_LITERAL >}